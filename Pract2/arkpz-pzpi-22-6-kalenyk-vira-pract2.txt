Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук


Кафедра програмної інженерії



ЗВІТ
до практичного заняття № 2
з дисципліни «Аналіз та рефакторинг коду»











Харків 2024

1.1	Тема роботи:
Методи рефакторингу коду.	
1.2 Мета роботи:
Навчитися основним методам рефакторингу коду на основі реальних прикладів із власних програмних проєктів. Освоїти навички ідентифікації проблем у коді та використання відповідних методів рефакторингу для покращення його якості, читабельності та ефективності..
1.3 Хід роботи
	1. Було обрано такі методи рефакторингу, як Replace Type Code with Class (заміна числових або строкових кодів типів на спеціалізовані класи), Substitute Algorithm (заміна існуючого алгоритму на більш простий, ефективний або відповідний до поточних вимог) та Tease Apart Inheritance (розділення складної ієрархії класів на дві або більше, кожна з яких відповідає за окрему відповідальність, із використанням делегування).
	2. Було зроблено опис кожного з методів рефакторингу.
Метод 1:
Метод Replace Type Code with Class (заміна коду типу класом) застосовується, коли у класі використовується числовий або строковий код для позначення певного типу, який не впливає на поведінку класу. Заміна такого коду на окремий клас підвищує читабельність коду та забезпечує кращу перевірку типів на рівні компілятора. 
Мотивація полягає в тому, що використання числових або строкових кодів типу може призвести до помилок, оскільки компілятор не може перевірити коректність таких значень. Заміна коду типу на клас дозволяє компілятору здійснювати перевірку типів, що значно зменшує ймовірність помилок і покращує підтримуваність коду.
Порядок рефакторингу складається з декількох етапів. Спочатку створюється новий клас, який буде представляти код типу, і надається йому відповідна назва, що відображає призначення. У новий клас додається поле, яке зберігатиме значення коду типу, а також метод для отримання цього значення. Потім створюються статичні константи у новому класі для кожного можливого значення коду типу. Після цього тип поля коду типу в оригінальному класі замінюється на новий клас, а методи доступу до поля коду типу оновлюються для роботи з цим класом. Нарешті, всі прямі звернення до значень коду типу замінюються на використання відповідних констант нового класу.
Якщо код типу впливає на поведінку класу (наприклад, використовується в умовних операторах if або switch), слід розглянути інші методи рефакторингу, такі як заміна коду типу підкласами або заміна коду типу стратегією. Це забезпечує гнучкішу і відповідальнішу структуру коду.
Метод 2:
Метод Substitute Algorithm (заміна алгоритму) застосовується в тих випадках, коли необхідно замінити існуючий алгоритм на більш простий, ефективний або відповідний до поточних вимог.
Проблема полягає в тому, що існуючий алгоритм може бути складним для розуміння, неефективним або не відповідати новим вимогам. Це може ускладнювати підтримку коду та його подальший розвиток. Рішенням є заміна тіла методу, який реалізує старий алгоритм, на новий алгоритм. Це дозволяє зробити код простішим, зрозумілішим і легшим для підтримки.
Причини рефакторингу цим методом можуть бути різними. Інколи метод настільки перенасичений проблемами, що його простіше переписати заново. У деяких випадках може бути знайдений більш простий і ефективний алгоритм. Також, з часом, алгоритм може бути включений у відому бібліотеку чи фреймворк, що дозволяє уникнути власної реалізації для спрощення підтримки. Нарешті, вимоги до програми можуть змінитися настільки, що адаптація старого алгоритму стане неможливою.
Порядок рефакторингу складається з кількох етапів. Спочатку слід спростити поточний алгоритм, виділивши несуттєвий код в інші методи за допомогою методу "витягування". Чим менше складових залишиться в початковому алгоритмі, тим легше буде його замінити. Далі створюється новий алгоритм у новому методі. Старий алгоритм замінюється новим, і запускаються тести програми. Якщо результати не збігаються, слід повернути стару реалізацію та порівняти результати, щоб визначити причини розходжень. Коли всі тести успішно пройдені, старий алгоритм видаляється остаточно.
	Метод 3:
	Метод Tease Apart Inheritance (розділення успадкування) застосовується у випадках, коли одна ієрархія класів намагається виконувати кілька завдань одночасно, що призводить до складності та заплутаності коду. Цей рефакторинг передбачає розділення такої ієрархії на дві окремі, кожна з яких відповідає за свою чітку відповідальність, із подальшим використанням делегування для забезпечення взаємодії між ними.
Проблема виникає тоді, коли ієрархія класів намагається охопити кілька аспектів або відповідальностей, що призводить до дублювання коду та ускладнює підтримку. Наприклад, якщо класи відповідають як за тип контенту (текст, зображення), так і за платформу (Facebook, Twitter), кількість класів зростає комбінаційно, що робить структуру громіздкою і важкозрозумілою. Рішенням є розділення ієрархії на дві окремі: одну для типів контенту, іншу для платформ. Делегування використовується для взаємодії між цими новими ієрархіями, що дозволяє зменшити дублювання коду та спростити його підтримку.
Кроки рефакторингу цим методом включають декілька етапів. Спочатку необхідно визначити окремі аспекти, які поєднуються в поточній ієрархії, наприклад, тип контенту та платформа. Далі створюється новий клас для одного з аспектів, який буде виконувати роль делегата. Потім відповідні методи з існуючих класів виділяються у новий делегат. У початкових класах прямі виклики методів замінюються на виклики через делегата. Процес повторюється для інших аспектів, якщо це необхідно.
Переваги цього підходу очевидні. По-перше, зменшується дублювання коду, оскільки кожна ієрархія відповідає за свій аспект, що значно спрощує підтримку. По-друге, покращується гнучкість: додавати нові типи контенту або платформи стає легше, не змінюючи існуючу логіку. Це робить код зрозумілішим і зручнішим для розширення.
3. Було використано описані методи рефакторингу для коду власних програмних проєктів.
Метод 1 (Replace Type Code with Class):
1.	// Код до:
2.	public class Task
3.	{
4.	      public string Title { get; set; }
5.	      public DateTime Date { get; set; }
6.	      public int TaskType { get; set; } // 0 - Work, 1 - Study, 2 - Personal
7.	
8.	public string GetTaskTypeName()
9.	{
10.	      switch (TaskType)
11.	      {
12.	            case 0: return "Work";
13.	            case 1: return "Study";
14.	            case 2: return "Personal";
15.	            default: return "Unknown";
16.	      }
17.	}
18.	}
19.	
20.	var task = new Task
21.	{
22.	      Title = "Complete project",
23.	      Date = DateTime.Now,
24.	      TaskType = 0 
25.	};
26.	Console.WriteLine($"Task: {task.Title}, Type: {task.GetTaskTypeName()}");
27.	
28.	// Код після рефакторингу:
29.	public class TaskType
30.	{
31.	      public string Name { get; }
32.	      private TaskType(string name)
33.	      {
34.	            Name = name;
35.	      }
36.	
37.	      public static readonly TaskType Work = new TaskType("Work");
38.	      public static readonly TaskType Study = new TaskType("Study");
39.	      public static readonly TaskType Personal = new TaskType("Personal");
40.	
41.	      public override string ToString() => Name;
42.	}
43.	.
44.	public class Task
45.	{
46.	      public string Title { get; set; }
47.	      public DateTime Date { get; set; }
48.	      public TaskType Type { get; set; }
49.	}
50.	
51.	var task = new Task
52.	{
53.	      Title = "Complete project",
54.	      Date = DateTime.Now,
55.	      Type = TaskType.Work // Замість числового коду
56.	};
57.	Console.WriteLine($"Task: {task.Title}, Type: {task.Type}");
Метод 2 (Substitute Algorithm):
1.	// Код до:
2.	public class Task
3.	{
4.	      public string Title { get; set; }
5.	      public DateTime DueDate { get; set; }
6.	}
7.	public class TaskPlanner
8.	{
9.	      public List<Task> SortTasksByDate(List<Task> tasks)
10.	      {
11.	            for (int i = 0; i < tasks.Count; i++)
12.	            {            
13.	                  for (int j = i + 1; j < tasks.Count; j++)
14.	                  {
15.	                        if (tasks[i].DueDate > tasks[j].DueDate)
16.	                              {
17.	                                    var temp = tasks[i];
18.	                                    tasks[i] = tasks[j];
19.	                                    tasks[j] = temp;
20.	                              }
21.	                        }
22.	                  }
23.	            return tasks;
24.	      }
25.	}
26.	// Код після рефакторингу:
27.	public class TaskPlanner
28.	{
29.	      public List<Task> SortTasksByDate(List<Task> tasks)
30.	      {
31.	            return tasks.OrderBy(t => t.DueDate).ToList();
32.	      }
33.	}
Метод 3 (Tease Apart Inheritance):
1.	// Код до:
2.	public class Task
3.	{
4.	      public string Title { get; set; }
5.	}
6.	public class ListTask : Task
7.	{
8.	      public void RenderAsList()
9.	      {
10.	            Console.WriteLine($"Task in list: {Title}");
11.	      }
12.	}      
13.	public class CalendarTask : Task
14.	{
15.	      public DateTime DueDate { get; set; }
16.	      public void RenderInCalendar()
17.	      {
18.	            Console.WriteLine($"Task in calendar: {Title} on {DueDate}");
19.	      }
20.	}
21.	public class ListEvent : ListTask
22.	{
23.	      public DateTime EventDate { get; set; }
24.	      public void RenderEventAsList()
25.	      {
26.	            Console.WriteLine($"Event in list: {Title} on {EventDate}");
27.	      }
28.	}
29.	public class CalendarEvent : CalendarTask
30.	{
31.	      public DateTime EventDate { get; set; }
32.	      public void RenderEventInCalendar()
33.	      {
34.	            Console.WriteLine($"Event in calendar: {Title} on {EventDate}");
35.	      }
36.	}
37.	// Код після рефакторингу:
38.	public class Task
39.	{
40.	      public string Title { get; set; }
41.	}
42.	public class Event : Task
43.	{
44.	      public DateTime EventDate { get; set; }
45.	}
46.	public interface IRenderer
47.	{
48.	      void Render(Task task);
49.	}
50.	public class ListRenderer : IRenderer
51.	{
52.	      public void Render(Task task)
53.	      {
54.	            if (task is Event eventTask)
55.	            {
56.	                  Console.WriteLine($"Event in list: {eventTask.Title} on {eventTask.EventDate}");
57.	            }
58.	            else
59.	            {
60.	                  Console.WriteLine($"Task in list: {task.Title}");
61.	            }
62.	      }
63.	}
64.	public class CalendarRenderer : IRenderer
65.	{
66.	      public void Render(Task task)
67.	      {
68.	            if (task is Event eventTask)
69.	            {
70.	                  Console.WriteLine($"Event in calendar: {eventTask.Title} on {eventTask.EventDate}");
71.	            }
72.	            else
73.	            {
74.	                  Console.WriteLine($"Task in calendar: {task.Title}");
75.	            }
76.	      }
77.	}
78.	var task = new Task { Title = "Buy groceries" };
79.	var eventTask = new Event { Title = "Team meeting", EventDate = DateTime.Now };
80.	IRenderer listRenderer = new ListRenderer();
81.	listRenderer.Render(task);
82.	listRenderer.Render(eventTask);
83.	IRenderer calendarRenderer = new CalendarRenderer();
84.	calendarRenderer.Render(task);
85.	calendarRenderer.Render(eventTask);
1.4 Висновок
В ході виконання практичної роботи було розглянуто три методи рефакторингу та описано їх застосування. На основі реальних прикладів із програмного коду були визначені проблемні місця, що потребували оптимізації, і виконано покрокове покращення за допомогою обраних методів. Було написано опис кожного методу, надано приклади коду до і після рефакторингу, а також пояснено, як ці зміни покращують структуру та якість програмного забезпечення. Практичні приклади допомогли закріпити теоретичні знання і зрозуміти, як обирати відповідний метод для вирішення конкретної проблеми в коді. Також була створена презентація, слайди якої наведено в додатку А.
1.5	 Список використаних джерел
1.	Fowler, Martin. Refactoring: Improving the Design of Existing Code. Second Edition. — Boston: Addison-Wesley, 2018. — 448 p.
2.	Офіційна документація C#: [вебсайт]. — Режим доступу: https://learn.microsoft.com/en-us/dotnet/csharp/ (дата звернення: 02.12.2024).
3.	Refactoring.Guru: [вебсайт]. — Режим доступу: https://refactoring.guru (дата звернення: 02.12..2024).
4.	JetBrains: [вебсайт]. — Режим доступу: https://www.jetbrains.com (дата звернення: 02.12..2024).
5.	Visual Studio: [вебсайт]. — Режим доступу: https://visualstudio.microsoft.com (дата звернення: 02.12..2024).
6.	Eclipse: [вебсайт]. — Режим доступу: https://www.eclipse.org (дата звернення: 02.12..2024).
1.6	 Посилання
Посилання на GitHub репозиторій: https://github.com/NureKalenykVira/arkpz-pzpi-22-6-kalenyk-vira/tree/main/Pract2
Посилання на відео доповіді: https://youtu.be/lzWilnfWQto

 
Додаток А
Слайди презентації
 
Рисунок А.1 – Титульний слайд
 
Рисунок А.2 – Зміст презентації
 
Рисунок А.3 – Вступ
 
Рисунок А.4 – Опис обраного методу рефакторингу № 1
 
Рисунок А.5 – Опис обраного методу рефакторингу № 2
 
Рисунок А.6 – Опис обраного методу рефакторингу № 3
 
Рисунок А.7 – Застосування обраного методу рефакторингу № 1
 
Рисунок А.8 – Застосування обраного методу рефакторингу № 2
 
Рисунок А.9 – Застосування обраного методу рефакторингу № 3
 
Рисунок А.10 – Огляд інструментів для рефакторингу
 
Рисунок А.11 – Висновки
 
Рисунок А.12 – Список використаних джерел
 
Рисунок А.13 – Завершальний слайд

