Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук


Кафедра програмної інженерії



ЗВІТ
до лабораторної роботи № 2
з дисципліни «Аналіз та рефакторинг коду»












Харків 2024

1 РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)

1.1 Мета роботи
    	Метою роботи є розробка бази даних для серверної частини програмної системи та прикладного програмного інтерфейсу.
1.2	 Хід роботи

1.2.1	Розробити будову програмної системи.
Програмна система для контролю свіжості продуктів у холодильнику буде мати клієнт-серверну архітектуру. Серверна частина буде реалізована за допомогою платформи Node.js для обробки запитів і управління даними. Для зберігання даних буде використовуватися реляційна база даних MySQL. Комунікація з клієнтами здійснюється через веб-інтерфейс, мобільний додаток та API для інтеграції з IoT-сенсорами холодильників. Аутентифікація користувачів буде здійснюватися через JSON Web Tokens для забезпечення безпеки.
Модулі серверної частини:
1.	Модуль авторизації та аутентифікації:
1)	Реєстрація нових користувачів (домогосподарств, ресторанів, адміністраторів);
2)	Авторизація користувачів з використанням JSON Web Tokens для безпечного доступу до системи.
2.	Модуль управління продуктами:
1)	Додавання, перегляд, редагування та видалення інформації про продукти;
2)	Оновлення стану продуктів на основі даних з IoT-сенсорів;
3)	Генерація сповіщень про наближення закінчення терміну придатності;
4)	Генерація сповіщень про закінчення терміну придатності.
3.	Модуль обробки даних IoT-сенсорів:
1)	Збір і обробка даних з датчиків температури, вологості та RFID-міток;
2)	Оновлення інформації про умови зберігання;
3)	Інтеграція з сенсорами для моніторингу кількох зон холодильника.
4.	Модуль сповіщень та рекомендацій:
1)	Надсилання сповіщень користувачам через мобільний додаток і веб-інтерфейс;
2)	Генерація рекомендацій щодо оптимального використання продуктів, базуючись на зібраних даних;
3)	Попередження про наближення терміну придатності продуктів.
5.	Модуль аналітики:
1)	Формування аналітичних звітів про стан продуктів, умови їх зберігання та ефективність використання;
2)	Аналіз даних для виявлення тенденцій і формування рекомендацій щодо зменшення харчових відходів.
6.	Модуль управління користувачами:
1)	Перегляд та редагування профілю користувача (налаштування сповіщень, дані про холодильник).
7.	Модуль адміністрування:
1)	Надання адміністраторам доступу до загальних налаштувань системи;
2)	Управління пристроями IoT (додавання або видалення сенсорів);
3)	Моніторинг роботи серверної частини системи.
8.	Модулі клієнтської частини:
1)	Перегляд списку продуктів із детальною інформацією про терміни придатності;
2)	Отримання сповіщень про стан продуктів;
3)	Управління налаштуваннями холодильника;
4)	Інтерфейс для адміністрування та аналізу даних;
5)	Візуалізація аналітичних звітів для користувачів.

1.2.2	Створити UML діаграму прецедентів для серверної частини системи.
Створено UML діаграму прецедентів для серверної частини системи, що представлена на рисунку 1.
 
Рисунок 1 - UML діаграма прецедентів для серверної частини системи

1.2.3	Створити ER діаграму даних.
Створено ER діаграму даних для серверної частини системи, що представлена на рисунку 2.
 
Рисунок 2 - ER діаграма даних для серверної частини системи

1.2.4	Розробити базу даних (БД) програмної системи.
Було розроблено базу даних програмної системи за допомогою наступних запитів: 
1.	CREATE DATABASE fridge_system;

2.	CREATE TABLE Users (
3.	UserID INT AUTO_INCREMENT PRIMARY KEY,
4.	Name VARCHAR(100),
5.	Email VARCHAR(255) UNIQUE,
6.	Password VARCHAR(255),
7.	Role ENUM('Admin', 'Regular User'),
8.	CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
9.	UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
10.	);

11.	CREATE TABLE Refrigerators (
12.	RefrigeratorID INT AUTO_INCREMENT PRIMARY KEY,
13.	UserID INT,
14.	Name VARCHAR(100),
15.	Location VARCHAR(255),
16.	CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
17.	UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
18.	FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE
19.	);

20.	 CREATE TABLE Products (
21.	    ProductID INT AUTO_INCREMENT PRIMARY KEY,
22.	    RefrigeratorID INT NOT NULL,
23.	    Name VARCHAR(255) NOT NULL,
24.	    Category VARCHAR(100),
25.	    ExpirationDate DATE NOT NULL,
26.	    RFIDTag VARCHAR(100),
27.	    AddedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
28.	    UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
29.	    FOREIGN KEY (RefrigeratorID) REFERENCES Refrigerators(RefrigeratorID) ON DELETE CASCADE
30.	);

31.	CREATE TABLE Sensors (
32.	SensorID INT AUTO_INCREMENT PRIMARY KEY,
33.	RefrigeratorID INT,
34.	Type ENUM('Temperature', 'Humidity', 'RFID'),
35.	Status ENUM('Active', 'Inactive'),
36.	CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
37.	UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
38.	FOREIGN KEY (RefrigeratorID) REFERENCES Refrigerators(RefrigeratorID) ON DELETE CASCADE
39.	);

40.	CREATE TABLE SensorData (
41.	DataID INT AUTO_INCREMENT PRIMARY KEY,
42.	SensorID INT,
43.	ProductID INT,
44.	Temperature FLOAT,
45.	Humidity FLOAT,
46.	Timestamp DATETIME,
47.	FOREIGN KEY (SensorID) REFERENCES Sensors(SensorID) ON DELETE CASCADE,
48.	FOREIGN KEY (ProductID) REFERENCES Products(ProductID) ON DELETE CASCADE
49.	);

50.	CREATE TABLE Notifications (
51.	NotificationID INT AUTO_INCREMENT PRIMARY KEY,
52.	UserID INT,
53.	DataID INT,
54.	Message TEXT,
55.	Status ENUM('New', 'Read'),
56.	CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
57.	FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE,
58.	FOREIGN KEY (DataID) REFERENCES SensorData(DataID) ON DELETE CASCADE
59.	);

1.2.5	Створити діаграму структури БД.
Створено діаграму структури бази даних, що представлена на рисунку 3.
 
Рисунок 3 – Діаграма структури бази даних

1.2.6	Розробити функції роботи з БД (ORM або CoRM тощо).
Було розроблено такі функції для роботи з базою даних за допомогою CoRM, як отримання всіх користувачів, отримання користувача за ID, додавання, оновлення та видалення користувача; отримання всіх холодильників, отримання холодильника за ID, додавання нового холодильника, оновлення та видалення холодильника, отримання холодильників для конкретного користувача та за локацією; отримання всіх датчиків, отримання датчика за ID, додавання, оновлення та видалення датчика, оновлення статусу датчика, отримання датчиків за холодильником та за типом; отримання всіх продуктів, отримання продукту за ID, додавання, оновлення та видалення продукту, отримання продуктів за холодильником, за категорією; отримання всіх даних датчиків, отримання даних за ID, додавання та видалення даних датчика, отримання даних за конкретним датчиком та продуктом; отримання всіх сповіщень, отримання сповіщення за ID, додавання нового сповіщення, оновлення статусу сповіщення, видалення сповіщення та отримання сповіщень за користувачем.

1.2.7	Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами.
Було розроблено RESTful API для взаємодії серверної частини з клієнтами, яке включає наступні функціональні можливості: отримання, додавання, оновлення та видалення даних для таблиць Users, Refrigerators, Sensors, Products, SensorData та Notifications. API підтримує запити на отримання конкретних записів за ID, фільтрацію за різними параметрами (наприклад, статус, категорія, тип, локація), а також оновлення статусів об'єктів. Запити реалізовані за допомогою методів HTTP: GET, POST, PUT, PATCH та DELETE.

1.2.8	Створити специфікацію розробленого API.
Було створено специфікацію розробленого API. Специфікація наведена в таблиці 1.

Таблиця 1 – Специфікація API 
Метод	Маршрут	Опис
GET	/users	Отримати всіх користувачів
GET	/users/:id	Отримати користувача за ID
POST	/users	Додати нового користувача
PUT	/users/:id	Оновити дані користувача
DELETE	/users/:id	Видалити користувача
GET	/refrigerators	Отримати всі холодильники
GET	/refrigerators/:id	Отримати холодильник за ID
POST	/refrigerators	Додати новий холодильник
PUT	/refrigerators/:id	Оновити дані холодильника
DELETE	/refrigerators/:id	Видалити холодильник
GET	/refrigerators/user/:userId	Отримати холодильники для конкретного користувача
GET	/refrigerators/location/:location	Отримати холодильники за локацією
GET	/refrigerators/:id/last-update	Отримати дату останнього оновлення холодильника
GET	/sensors	Отримати всі датчики
GET	/sensors/:id	Отримати датчик за ID
POST	/sensors	Додати датчик
PUT	/sensors/:id	Оновити датчик
DELETE	/sensors/:id	Видалити датчик
GET	/sensors/refrigerator/:refrigeratorId	Отримати датчики за холодильником
PATCH	/sensors/:id/status	Оновити статус датчика
GET	/sensors/type/:type	Отримати датчики за типом 
GET	/products	Отримати всі продукти
GET	/products/:id	Отримати продукт за ID
POST	/products	Додати новий продукт
PUT	/products/:id	Оновити продукт
DELETE	/products/:id	Видалити продукт
GET	/products/refrigerator/:refrigeratorId	Отримати продукти для холодильника
GET	/products/category/:category	Отримати продукти за категорією
GET	/sensor-data	Отримати всі дані датчиків
GET	/sensor-data/:id	Отримати дані датчика за ID
POST	/sensor-data	Додати нові дані датчика
PUT	/sensor-data/:id	Оновити дані датчика
DELETE	/sensor-data/:id	Видалити дані датчика
GET	/sensor-data/sensor/:sensorId	Отримати дані за датчиком
GET	/sensor-data/product/:productId	Отримати дані за продуктом
GET	/sensor-data/date	Отримати дані за датою
GET	/notifications	Отримати всі сповіщення
GET	/notifications/:id	Отримати сповіщення за ID
POST	/notifications	Додати нове сповіщення
PATCH	/notifications/:id/status	Оновити статус сповіщення
DELETE	/notifications/:id	Видалити сповіщення
GET	/notifications/user/:userId	Отримати сповіщення для користувача

1.2.9	Створити програмну реалізацію розробленого API та функцій роботи з БД.
Було створено програмну реалізацію розробленого API та функцій роботи з базою даних у проекті fridge-system. У папці routes були визначені маршрути для відповідних сутностей: userRoutes.js, refrigeratorRoutes.js, sensorRoutes.js, productRoutes.js, sensorDataRoutes.js та notificationRoutes.js, де кожен маршрут викликає методи відповідних контролерів. У папці controllers розміщено логіку обробки запитів для кожної сутності: userController.js, refrigeratorController.js, sensorController.js, productController.js, sensorDataController.js та notificationController.js. Водночас у папці repositories реалізовано функції взаємодії з базою даних для кожної сутності у файлах userRepository.js, refrigeratorRepository.js, sensorRepository.js, productsRepository.js, sensorDataRepository.js та notificationRepository.js. База даних підключається через файл db.js, а для обробки асинхронних помилок використано проміжне ПЗ у файлі asyncHandler.js. Головний файл index.js відповідає за ініціалізацію сервера та підключення маршрутів. Для перевірки та тестування розробленого API було створено колекцію запитів у Postman, де також була розроблена програмна версія специфікації API. У Postman були задокументовані всі запити для роботи з базою даних, включно з методами GET, POST, PUT, PATCH та DELETE для сутностей Users, Refrigerators, Sensors, Products, SensorData та Notifications. Перелік частини створених у Postman запитів представлено на рисунку 5. 
 
Рисунок 5 – Програмна версія специфікації API у Postman

1.2.10	 Перевірити роботу створеного програмного коду серверної частини системи.
Було проведено перевірку роботи створеного програмного коду серверної частини системи за допомогою Postman. Для кожного маршруту було виконано тестові HTTP-запити, включно з методами GET, POST, PUT, PATCH та DELETE, що відповідають функціоналу для сутностей Users, Refrigerators, Sensors, Products, SensorData та Notifications. Приклад тестування деяких запитів наведено на рисунках 6 - 8.
 
Рисунок 6 – Приклад тестування API за допомогою Postman (додавання нового користувача)
 
Рисунок 7 – Приклад тестування API за допомогою Postman (оновлення статусу сенсора)
 
Рисунок 8 – Приклад тестування API за допомогою Postman (отримання всіх холодильників користувача)

1.3	 Висновок
В ході виконання даної лабораторної роботи було розроблено будову програмної системи, створено UML та ER діаграми, а також діаграму структури бази даних. Також було розроблено базу даних, функції для роботи з базою даних, API для взаємодій та специфікацію API, програмну реалізацію API та проведено функціональне тестування створеного програмного коду серверної частини.

1.4	 Список використаних джерел
Для виконання цієї роботи були використані наступні джерела:
1.	Lucidchart. Онлайн-інструмент для створення діаграм [Електронний ресурс]. – Режим доступу: https://lucid.app/lucidchart – Дата доступу: 10.12.2024.
2.	Creately. Платформа для створення діаграм і графічних схем [Електронний ресурс]. – Режим доступу: https://app.creately.com/ – Дата доступу: 10.12.2024.
3.	MySQL. Офіційна документація системи управління базами даних [Електронний ресурс]. – Режим доступу: https://dev.mysql.com/doc/ – Дата доступу: 11.12.2024.
4.	Node.js. Довідник та документація серверної платформи [Електронний ресурс]. – Режим доступу: https://nodejs.org/en/docs/ – Дата доступу: 11.12.2024.
5.	Docker. Офіційна документація системи контейнеризації [Електронний ресурс]. – Режим доступу: https://docs.docker.com/ – Дата доступу: 11.12.2024.
6.	Postman. Документація для інструмента тестування API [Електронний ресурс]. – Режим доступу: https://learning.postman.com/docs/ – Дата доступу: 12.12.2024.

1.5	 Посилання
Посилання на репозиторій git hub: https://github.com/NureKalenykVira/arkpz-pzpi-22-6-kalenyk-vira/tree/main/Task2.
Посилання на відео-доповідь: https://youtu.be/reewGaT_Tcs.
